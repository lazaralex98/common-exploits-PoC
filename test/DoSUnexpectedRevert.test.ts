import { SignerWithAddress } from '@nomiclabs/hardhat-ethers/signers';
import { expect } from 'chai';
import { formatEther, parseEther } from 'ethers/lib/utils';
import hre, { ethers } from 'hardhat';
import {
  SimpleAuction,
  AuctionDoSAttacker,
  CrowdFunding,
  CrowdFundingDoSAttacker,
} from '../typechain-types/DoSUnexpectedRevert.sol';

async function getEthBalance(address: string) {
  return await ethers.provider.getBalance(address);
}

async function getFormattedEthBalance(address: string) {
  return formatEther(await getEthBalance(address));
}

describe('DoS attacking a simple auction', function () {
  let targetOwner: SignerWithAddress;
  let attackerOwner: SignerWithAddress;
  let addrs: SignerWithAddress[];
  let targetContract: SimpleAuction;
  let attackerContract: AuctionDoSAttacker;

  before(async function () {
    [targetOwner, attackerOwner, ...addrs] = await ethers.getSigners();

    // target owner deploys target contract
    const TargetFactory = await hre.ethers.getContractFactory('SimpleAuction');
    targetContract = await TargetFactory.connect(targetOwner).deploy();
    await targetContract.deployed();

    // target owner bids ETH
    await targetContract.connect(targetOwner).bid({ value: parseEther('10.0') });
    expect(
      await targetContract.currentLeader(),
      'Target owner should lead the auction'
    ).to.be.equal(targetOwner.address);

    // attacker owner deploys attacker contract
    const AttackerFactory = await hre.ethers.getContractFactory('AuctionDoSAttacker');
    attackerContract = await AttackerFactory.connect(attackerOwner).deploy(targetContract.address);
    await attackerContract.deployed();
  });

  it('should be able to bid and take the lead', async function () {
    // attacker contract bids ETH
    await attackerContract.connect(attackerOwner).bid({ value: parseEther('11.0') });
    expect(
      await targetContract.currentLeader(),
      'Attacker contract should lead the auction'
    ).to.be.equal(attackerContract.address);
  });

  it(`shouldn't be able to bid anymore`, async function () {
    // target owner bids ETH and it fails because the attacker denies it
    await expect(
      targetContract.connect(targetOwner).bid({ value: parseEther('12.0') })
    ).to.be.revertedWith('failed to refund');
  });
});

describe('DoS attacking a simple crowdfunding contract', function () {
  let targetOwner: SignerWithAddress;
  let attackerOwner: SignerWithAddress;
  let addrs: SignerWithAddress[];
  let targetContract: CrowdFunding;
  let attackerContract: CrowdFundingDoSAttacker;

  before(async function () {
    [targetOwner, attackerOwner, ...addrs] = await ethers.getSigners();

    // target owner deploys target contract
    const TargetFactory = await hre.ethers.getContractFactory('CrowdFunding');
    targetContract = await TargetFactory.connect(targetOwner).deploy();
    await targetContract.deployed();

    // attacker owner deploys attacker contract
    const AttackerFactory = await hre.ethers.getContractFactory('CrowdFundingDoSAttacker');
    attackerContract = await AttackerFactory.connect(attackerOwner).deploy(targetContract.address);
    await attackerContract.deployed();
  });

  it('should be able to fund', async function () {
    // different users crowdfund ETH
    await targetContract.connect(addrs[0]).fund({ value: parseEther('10.0') });
    await targetContract.connect(addrs[1]).fund({ value: parseEther('100.0') });
    await targetContract.connect(addrs[2]).fund({ value: parseEther('50.0') });
    await targetContract.connect(addrs[3]).fund({ value: parseEther('20.0') });

    // attacker contract funds small amount of ETH
    await attackerContract.connect(attackerOwner).fund({ value: parseEther('0.01') });

    const totalFunded = await targetContract.totalFunds();
    expect(totalFunded, 'Total funds should be 180.01 ETH').to.be.equal(parseEther('180.01'));
  });

  it(`shouldn't be able to refund anyone`, async function () {
    // target owner tries to refund all funders and it fails because the attacker denies it
    await expect(targetContract.connect(targetOwner).refundAll()).to.be.revertedWithCustomError(
      targetContract,
      `SendingFailed`
    );
  });
});
