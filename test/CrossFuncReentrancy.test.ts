import { SignerWithAddress } from '@nomiclabs/hardhat-ethers/signers';
import { expect } from 'chai';
import { BigNumber } from 'ethers';
import { formatEther, parseEther } from 'ethers/lib/utils';
import hre, { ethers } from 'hardhat';
import { CFRA, CFRT } from '../typechain-types';
import chalk from 'chalk';

async function getEthBalance(address: string) {
  return await ethers.provider.getBalance(address);
}

async function getFormattedEthBalance(address: string) {
  return formatEther(await getEthBalance(address));
}

describe('CrossFuncReentrancy', function () {
  let targetOwner: SignerWithAddress;
  let attackerOwner: SignerWithAddress;
  let addrs: SignerWithAddress[];
  let targetContract: CFRT;
  let attackerContract: CFRA;
  let attackerBalances: BigNumber[] = [];

  before(async function () {
    [targetOwner, attackerOwner, ...addrs] = await ethers.getSigners();

    // target owner deploys target contract
    const TargetFactory = await hre.ethers.getContractFactory('CFRT');
    targetContract = await TargetFactory.connect(targetOwner).deploy();
    await targetContract.deployed();

    // target owner sends ETH to target contract (to be drained by attacker later)
    await targetContract.connect(targetOwner).deposit({ value: parseEther('100.0') });

    expect(
      await getFormattedEthBalance(targetContract.address),
      `Target contract should have 100.0 ETH.`
    ).to.equal('100.0');
    expect(
      formatEther(await targetContract.balances(targetOwner.address)),
      `Target owner should have 100.0 ETH. within target contract.`
    ).to.equal('100.0');
    expect(
      await getFormattedEthBalance(attackerOwner.address),
      `Attacker owner should have 10000.0 ETH initially.`
    ).to.equal('10000.0');

    // attacker owner deploys attacker contract
    const AttackerFactory = await hre.ethers.getContractFactory('CFRA');
    attackerContract = await AttackerFactory.connect(attackerOwner).deploy(targetContract.address);
    await attackerContract.deployed();

    expect(
      await getFormattedEthBalance(attackerContract.address),
      `Attacker contract should have 0.0 ETH.`
    ).to.equal('0.0');
    expect(
      formatEther(await targetContract.balances(attackerContract.address)),
      `Attacker contract should have 0.0 ETH within target contract.`
    ).to.equal('0.0');
  });

  it('should deposit 50 ETH from attacker to target', async function () {
    // attacker owner deposits ETH via attacker contract to
    // target (so the attacker contract has a balance)
    await attackerContract.connect(attackerOwner).deposit({ value: parseEther('50.0') });

    expect(
      await getFormattedEthBalance(targetContract.address),
      `Target contract should have 150.0 ETH.`
    ).to.equal('150.0');
    expect(
      formatEther(await targetContract.balances(attackerContract.address)),
      `Attacker contract should have 50.0 ETH within target contract.`
    ).to.equal('50.0');
  });

  it('should manipulate balances in target', async function () {
    // use a cross-function reentrancy attack to
    // 1. unfairly manipulate balances so the attacker owner has 50 ETH in target
    // (when they never deposited themselves)
    // 2. withdraw the 50 ETH deposited by the attacker contract earlier
    // from target into attacker contract
    await attackerContract.attack();

    expect(
      formatEther(await targetContract.balances(attackerContract.address)),
      'Attacking contract should have an in-target balance of 0.0 ETH'
    ).to.equal('0.0');
    expect(
      await getFormattedEthBalance(attackerContract.address),
      'Attacking contract should have an ETH balance of 50.0 ETH'
    ).to.equal('50.0');
    expect(
      formatEther(await targetContract.balances(attackerOwner.address)),
      'Attacker owner should have an in-target balance of 50.0 ETH'
    ).to.equal('50.0');
  });

  it('should withdraw 50 ETH from target to attacker', async function () {
    // owner of attacker withdraws from target & attacker contracts
    await (await targetContract.connect(attackerOwner).withdraw()).wait();
    await (await attackerContract.connect(attackerOwner).withdraw()).wait();

    expect(
      await getFormattedEthBalance(targetContract.address),
      `Target contract should have 50.0 ETH.`
    ).to.equal('50.0');
    expect(
      await getFormattedEthBalance(attackerContract.address),
      `Attacker contract should have 50.0 ETH.`
    ).to.equal('0.0');

    // TODO too lazy to calculate all the dust ETH lost around
    // but the attacker owner should have ~10_050 ETH.
    console.log(
      chalk.blue.bold(
        `Attacker owner's ETH balance: ${await getFormattedEthBalance(attackerOwner.address)}`
      )
    );
    expect(await getEthBalance(attackerOwner.address)).to.be.gt(
      parseEther('10000.0'),
      'Attacker owner should have more ETH after the attack.'
    );
  });
});
